<!-- 
 1)GETTING STARTED
-----------------
	METHODOLOGY
			Byte size lesson for specific topic
				1)Brief intro to idea
				2)why importance
				3)demos to reinforce
				4)quizes & exercises to test knowledge
				3)additional resources
			Your responsability
				1)follow along
				2)experiment & change
				3)engage in community
				4)comment and ask questions
				3)stay consistent
				4)avoid skipping lessons
				5)read deep work
				6)mistakes are natural
			Comparison of how web works for 
				1)vanilla js
				2)react
				3)nextjs
			Interactive lessons
				Mental model of approach to smallest aspect of webdev
	ENVIRONMENT
		VS CODE
			1)fira code font -> Fira Mono
			2)ligatures
			3)catpuccin theme
			4)babel js
				syntax highlighting
			5)better comments
				diff colored comments
			6)eslint
				highlight the erros
			7)es7 react
				snippets
			8)copilot
			9)intellicode
				In the most recent update, IntelliCode can predict up to a whole line of code based on your current context for Python, JavaScript, and TypeScript.
			10)material icon theme
			11)mdx
			12)npm intellisense
				autocompletes path import modules
			12)path intellisense
				autocompletes filenames
			13)prettier
			14)prettier eslint
			15)pretty typescript errors
				parses the erros like a json extension 
			16)tailwind css intellisense
			17)errorlens
				puts error messages from problems tab -> next to the line
			18)peacock
				color border for different vs code windows
			19)live share
				take control of other editor to code
			20)tailwind fold
				hides long classname
			21)gitlens
			22)git history

2)INTRO & PREREQUISITES
-----------------------
	PREREQUISITE
		1)JS
			1)vars
			2)operators
			3)functions
			4)arrays & methods
			5)async - await
			6)try - catch
			7)ES6 arrow function
			8)let and const
			9)destructuring
			10)template strings
			11)spread and rest operators
		2)react
			1)components
			2)props
			3)state
			4)jsx
			5)functional components
			6)styling
			7)conditional rendering
			8)mapping over lists
			9)hooks
			10)useState
			11)useEffect
		3)next
			NONE
	
	STACK
		1)nextjs 15
		2)mongo db 
		3)tailwind
		4)figma
		5)Shadcn
		6)React Hook Form
		7)Zod
		8)Typescript

	OBJECTIVES / TOPICS TO LEARN
		1)setting up next.js project
			1)exploring and comparing various setup methods
		2)utilizing tools
			1)eslint
			2)prettier
			3)git
			4)github
		3)integrating
			1)tailwind
			2)chadCN
		4)constructing well-focused code architecture
		5)Next.js
			5)fundamentals
				1)client vs server architecture
				2)runtime vs build time
				3)rendering strategies like SSR, ISG, SSG, CSR
				4)thinking and approach in next.js
			6)routing
				1)normal routes
				2)dynamic routes
				3)nested routes
				4)route groups
				5)parallel routes
				6)intercepting routes
			7)authentication methods
				1)email & pass
				2)socials(google / github)
			8)authorization concepts
				1)public routes
				2)private routes
			9)multiple layouts
			10)optimizing fonts
			11)enhancing SEO
			12)Context API within Next.js server architecture
			13)Data fetching for all rendering strategies
			14)Revalidation & caching
			15)Building backend
			16)Exploring API Routes
			17)Server actions
		6)Understanding different dbs
			1)mongoDB 
				1)aggregation pipelines
				2)mongoose
		7)Open AI for automated answers
		4)Classic algorithms
			1)for building recommendation system
			2)global database search
			3)badge system
			4)reputation
			5)interacted data listing
		8)Tailwind
			1)develop responsive and complex UI
			2)light and dark theme
			3)unique properties & utility extensions
		9)Figma as a developer
		10)Shadcn
		11)React Hook Form
		12)Zod
		13)Typescript
			1)types
			2)interfaces
			3)extends
		14)Features
			1)counting page views
			2)voting system
			3)advaned filters
			4)specialized search mechanism filter
			5)pagination
			6)3rd party api integration
			7)markdown
	FEATURES    
		By page if page, else stand alone feature
		1)Home
			1)debounced search
			2)questions list
			3)sorting
			4)ask a question
			5)pagination 
		2)Community
			1)users list
			2)search
			3)filter
		3)Collections
			1)question list
		4)Find Jobs
			1)search
			2)filter 
			3)job list from popular apis
		5)Tags
			1)tags list
			2)search
			3)filter
		6)Profile
			1)user details
			2)edit profile
				1)form
			3)stats
			4)user activity
				1)posts
				2)answers
			5)top tags
		7)ASk a question
			1)form 
				1)title
				2)question markdown
				3)tags
		8)Auth(nextAuth)
			1)log in 
			2)sign up
		9)layout
			1)left sidebar
			2)right sidebar
				1)top questions
					1)algorithm for recommendation
				2)popular tags  
			3)search globally
				1)list of tag,user,question,answer that matches search
				2)filter
			4)theme
				1)light
				2)dark
		10)question details page
			1)question details
			2)markup
			3)tags
			4)vote
			5)save to collection
			6)answers
				1)vote
				2)markdown editor
				3)pagination
				4)generate AI answer
		11)tag details page
			1)search 
			2)questions associated to tag list
		12)mobile
			1)sidebar
			2)filters
			3)views

3)INTRO TO NEXTJS
-----------------
	BEFORE
		History
			React entered scene in 2015
			Js developed in 1995 by Brenden Eich
		New tools
			Why created
				Enhance work efficiency
				Improve Performance
			Why development becomes more efficient with tools
				Encourages reusability which enhances:
					Maintainability
					Scalability
				Ecosystem and community
					Abundant resources
					Extensive Documentation
					Reusable Code
					Bug Fixes
					Support
		What React brought to the table
			Virtual DOM(Lightweight rep of Real DOM)
				WHY
					Updates to DOM become more:
						Efficient
						Optimized
				HOW
					Diffing process
						Keeps track of changes and updates only what changed 
			Completely transformed approach to design and developing applications
				HOW
					Encourages to think about components & break down UI
					State to introduce interactivity 
					Connections between components shape application flow
		React Limitations
			Poor SEO
			High Initial Page load time
	Nextjs(Flexible React Framework)
		WHAT
			Full Stack Framework that encompasses client(front) and server(back) functionalities within a single application

			Framework
				Tool equipped with predefined rules and conventions that offer structured way to construct an app.
		PROVIDES (AS A FRAMEWORK)
			Environment that outlines
				1)overall architecture
				2)design patterns   
					Proven solutions to common programming problems
					Blueprints that help developers structure code in efficient, maintainable, reusable way.
				3)workflows
			Built-in solutions for common functionalities
				1)integrating dbs
				2)Managing routing
				3)handling authentication
		ALLOWS
			More focus on implementing specific app logic rather than low level design        
		PROVIDES(FOR FRONT END)
			Abstraction of configuration,repetitive and time consuming tasks
				1)Compiling
				2)Bundling
				3)Minifying
				4)Formatting
				5)Deploying
		PROVIDES(BACK END)
			Abstraction of back end features
				1)configuration and setup of server
				2)routes
		COMPARISON WITH OTHER TOOLS
			React and express == Next
		BUILT IN FEATURES
			1)server side rendering
			2)static site generation
			3)automatic code splitting
		KEY BENEFITS
			1)optimize application performance
			2)enable faster initial page load times
			3)improve SEO
			4)enhance UX
		WHY NEXT IF REACT OFFERS SSC
			Next leverages react features MINUS extensive setup and configuration PLUS Automates many aspects allowing focus on features rather than infrastructure and boilerplate code
		SEO WITH REACT AND NEXT
			React
				brief html(hinders what SEO bugs can find)
				huge js file
			next(static site generation / server side rendering)
				complete html file(perfect for SEO bugs)
				minimal js for client interaction
			result
				search engine crawlers access full site
		Companies using next
			notion
			hulu
			netflix
			nike
			hbo max
			audible
			ted
			hyundai
			porsche
			replit
			marvel
			materialUI
			coca cola
			ferrari
	HOW WEB WORKS(For every request:)
		Vanilla js
			Process
				1)Server responds with 3 whole files(html,css,js)
				2)Analyzes html
				3)Applies styles
				4)Implements interaction
			Metrics
				High Processing
				High Bandwidth
				High SEO
				High Loadtime
		React
			Process
				1)server response with minimal html with huge js that renders on client
				2)react updates virtual dom
				3)routing library to client navigate without full refresh
			Metrics
				High Complexity
				High Learning Curve
				High Processing
				Low SEO
				High Loadtime
		Next
			Process
				1)SSR & SSG sending complete html with minimal js
	
4)NEXTJS DOCUMENTATION SUMMARY 
------------------------	
	0)PROJECT STRUCTURE [dt: 06/04/25]
    Overiew of folder and file convention in Next.js. 

    TOP-LEVEL FOLDERS
      1)app
          app router

      2)pages
          pages router
      3)public
          static assets to be served
      4)src
          optional application source folder
    ROUTING FILES
      Next offers several name reserved special files of a route segement that serve different pre defined purposes

      1)layout
      2)page
      3)loading
      4)not-found
      5)error
      6)global-error
      7)route
      8)template
      9)default

    COMPONENT HIERARCHY
      Special files of a route segment are rendered in a specific hierarchy
      
      1)layout
      2)template
      3)error
      4)loading
      5)not-found
      6)page

    COLOCATION(default)
      Routes are NOT publicly accesible UNTIL a page.js file is added to a route segment.

      WHAT IS RETURNED TO CLIENT
        ONLY content in page.js or route.js
        NO other file is sent to client
  
    PRIVATE FOLDERS
      Prefixing a folder with an underscore

      SYNTAX
        _folderName
      
      WHY
        Files are colocated by default, private folders are NOT required for colocatio, but useful for:
          1)separating UI logic from routing logic
          2)consistently organizing internal files acrros a project
          3)sorting and grouping files
          4)avoifing potential naming conflicts

      EXAMPLE 
        dashboard(folder)
          _components(folder)
            button.js(file)
          page.js(page to render for /dashboard route)
                
    ROUTE GROUPS
      Indicates folder is for organizational purposes and should not be included in routes URL path

      SYNTAX
        (folderName)
                
      WHY 
        Group related routes (folders / files ) together
    
    COMMON STRATEGIES
      app
        purely routing purposes
      
  1)ROUTING [19/04/25]
    File system based routing, using folders and files to define routes.

    1)REGULAR ROUTES
      FOLDER
        Folder name matches route segment, and will render the page.tsx inside it to that specific route segment.

      PAGE(special file)
        UI rendered on a specific route(folder name).
            
      ABSTRACTS(in routing)
        1)Configure browerRoute,routes,route
        2)Provide URL path that will link to a component for rendering
        3)Encapsulates the routing in the file system and removes it from the layout file
        4)No need to download 3rd party package

      IN REACT
        import {BrowserRouter, Route, Routes, Link} from 'react-router-dom'

        <Router>
          <Routes>
          <Route path="/" element={<Home/>}></Route
          <Route path="/about" element={<About/>}></Route
          <Route path="/contact" element={<Contact/>}></Route
          </Routes>
        </Router>

      IN NEXT
        about(folder)   -> /about route
            page.tsx    -> about component
        contact(folder) -> /contact route
            page.tsx    -> contact component
        /root directory -> base url
          page.tsx      -> base component

    2)LINKING AND NAVIGATING[19/04/25]
      There exist four main ways of navigation:
        1)<Link> Component
          Primary way to navigate between routes in Next.js

          WHERE
            server components only

          EXAMPLE
            import Link from 'next/link'
  
            export default function Page() {
              return <Link href="/dashboard">Dashboard</Link>
          }
        2)useRouter() hook
          WHERE
            client components only
        3)redirect function
          WHERE
            Server Components only
          
    3)NESTED ROUTES[19/04/25]
      Just as a nested route has nested segments route segments, the file system will require nested folders. 

      EXAMPLE
        projects (folder) -> /projects route
          page.tsx        -> projects component
          list(folder)    -> /projects/list route
            page.tsx      -> projets-list component
        /root directory   -> base url
          page.tsx        -> base component

    4)LAYOUT(special file)[19/04/25]
      UI shared between multiple pages.

      HOW
        Layout will auto receive a layout / page file as children, you just have to acCept the children prop.

      ABSTRACTS(in layout)
        1)Creating a route and nesting other routes inside it
        2)Defining an index element to be the default for the specific route
        3)Defining an outlet in the layout component

      COMPARISON REACT VS NEXT
        REACT
          <BrowserRouter>
            <Routes>
              <Route path="/" element={<Layout />}>
                <Route index element={<Home />} />
                <Route path="about" element={<About />} />
              </Route>
            </Routes>
          </BrowserRouter>

          export default function Layout() {
            return (
              <>
                <header>Header</header>
                <Outlet />
                <footer>Footer</footer>
              </>
            );
          }
        NEXT
          1)define route folder
          2)create layout.ts file inside folder
          3)render the children prop {children}
      
      PROJECT LAYOUT
        Required at the root of the /app directory,
        Contains html and body tags.
      
      NESTING LAYOUTS
        You can nest layouts by adding layout.ts inside a specific route folder.
      
        EXAMPLE
          app(folder)
            layout.ts
              blog(folder)
                layout.ts

    5)DYNAMIC ROUTES[19/04/25]
      Route where part of the URL changes based on dynamic data(segment). 

      CREATING DYNAMIC SEGMENT
        Wrapping folder name in brackets []

        EXAMPLE
          dashboard(folder)    -> /dashboard route
            page.tsx           -> dashboard component
            users(folder)      -> /dashboard/users route
              page/tsx         -> dashboard-users component
              [userId](folder) -> dashboard/users/userId route
                page.tsx       -> dashboard-users-user component
          root folder          -> directory
            page.tsx           -> root component

      PARAMS
        Dynamic Segments from dynamic routes

        PLACES WHERE PARAMS ARE PASSED:
          1)layout
          2)page
          3)route
          4)generateMetadata functions.

        USING PARAMS TO ACCESS DYNAMIC DATA
          WHERE
            Only server components

          EXAMPLE
            export default async function Page({params}) {
              const { slug } = await params
              return <div>My Post: {slug}</div>
            }
        TYPE
          {params: Promise<{ slug: string }>}
        
        GOOD TO KNOW
          Params = promise, must use async-await

      useParams()
        Client component hook that provides the dynamic segment from a URL.

        EXAMPLE
          'use client'
          import { useParams } from 'next/navigation'
          export default function ExampleClientComponent() {
            const params = useParams()
            console.log(params)
            return '...'
          }

    6)ROUTE GROUPS[19/04/25]
      Route Group to prevent the folder from being included in the route's URL path. 

      CONVENTION  
        (folderName)

      EXAMPLE
        (auth) folder       -> route group:url not affected
          login(folder)     -> /login route
            page.tsx        
          register(folder)  -> /register route
            page.tsx        
        (dashboard)         -> route group: url not affected
          about(folder)     -> /about route
            page.tsx        
          contact(folder)   -> /contact route
            page.tsx
        /root directory     -> / route
          page.tsx          

      BENEFIT        
        Organize your route segments and project files into logical groups without affecting the URL path structure.
    
    3)ERROR HANDLING
      Divided into two categories
        1)expected errors
        2)uncaught exceptions

      EXPECTED ERRORS
        WHAT
          During normal operation like
            1)server side form validation
            2)failed requests
        OUTCOME
          Handled explicitly and returned to client
        HOW
          useActionState() to manage state of server actions.
        WHY
          Avoids try / catch blocks for expected errors 
        not really sure how this works...
        
      UNCAUGHT EXCEPTIONS
        WHAT
          Bugs or errors that should not occur during the normal flow of the app. 
        HOW
          Should be handled by throwing errors, WHICH should be caught by error boundaries.

        ERROR BOUNDARIES
          Catch errors in child components and display fallback UI

        REQUIREMENT
          'use client' // Error boundaries must be Client Components

        TYPES
          Different error boundaries to provide fallback UI:
            1)common
              root layout uncaught errors -> error.js
            2)optional
              ganular nested uncaught errors -> error.js
            3)uncommon
              root layout uncaught errors -> global-error.js

        ERRORS IN NESTED ROUTES
          Errors will bubBle up to the nearest parent error boundary.

          WHY
            allows granular control by placing error.ts at different levels of the route hierarchy.

        GLOBAL ERRORS
          Can handle errors in the root layout using global-error.ts.

          REQUIREMENT
            must define its own <html> and <body> tags, since it is replacing the root layout or template when active.

        ABSTRACTS
          Instead of writing error boundaries, retry logic, and fallback UIs by hand:
            1)Just drop an error.tsx file where you want scoped error handling
            2)Get built-in retry logic with reset()
            3)Handle both client and server errors uniformly

    4)LOADING UI & STREAMING
      loading.js helps create meaningful loading UI with React Suspense.

      INSTANT LOADING
        Instant loading UI upon navigation with a loading.js inside a folder

        HOW
          Auto wraps a page.js inside a Suspense boundary

          EXAMPLE
              <Suspense fallback={<Loading/>}>
                  <Page>
              </Suspense>

        ABSTRACTION
          1)state to handle loading value
          2)manually changing value of loading state
          3)condition the loading component to appear
          4)manual usage on every component that needs loading

        BENEFIT
          1)scoping different loading based on project structure

      SUSPENSE AND STREAMING
        tbd...
      
    5)REDIRECTING
    8)PARALLEL ROUTES
    9)INTERCEPTING ROUTES
    10)ROUTE HANDLERS(Creating Traditional APIs in Next.js) [dt:08/04/25]
      Allow to create custom request handlers for a given route with REQEUST and RESPONSE api AND extends the NEXTREQUEST AND NEXTRESPONSE apis. 

      COMPARISON WITH PAGES ROUTER
        Route handlers === API routes from pages directory / router
        NO NEED to use Route Handlers AND API routes together
      
      CONVENTION
        app -> must be inside app folder
          api -> must be inside api folder
            route.js/ts -> route!

      EXAMPLE
        export async function GET(request: REQUEST) {
          return Response.json({message: "Hello from api route in backend. (No server configured)."})
        }

      REQUISITE
        Can be placed anywhere EXCEPT a folder that has a page.js already. They come into conflict with each other. 
        
      ABSTRACTION
        It is possible to create routes without:
          1)setup server
          2)managing server
          3)listen server
          4)configure middleware

      BENEFIT
        1)More logic focused less configuration focused

      DYNAMIC ROUTE HANDLERS
        Route handlers can use dynamic segments (Use data filled in at request time) to create request handlers from dynamic data. 

        EXAMPLE
          ROUTE PATH
            app/books/[slug]/route.ts

          ROUTE HANLDER
            export async function GET(request: REQUEST, {params}:{params:Promise<{slug:string}>}) {
              const {slug} = await params
            }

      URL QUERY PARAMETERS
        Object passed to the route handleris  a NextRequest which extends Web Request API with additional convenience methods to easily handle query parameters.

        EXAMPLE
          import { type NextRequest } from 'next/server'
          export function GET(request: NextRequest) {
            const searchParams = request.nextUrl.searchParams
            const query = searchParams.get('query')
            // query is "hello" for /api/search?query=hello
          }

      HOW TO USE THE ROUTE HANDLERS IN THE UI 
        Call the route from a client/server UI page.js/ts component

        CONVENTION
          app
            books
              page.js -> component calling the route handler defined here
            api
              books
                route.js -> route handler defined here

        EXAMPLE
          async function Page(){
            const response = await fetch("domain/api/route")
            const books = response.json()

            return (
              <books>
            )
          }
      
    11)MIDDLEWARE
    12)INTERNALIZARTION

  2)RENDERING [dt:07/04/25]
    Convertion of written code into UI.
    Execution of js code into html

    0)FUNDAMENTALS
      0)THE TIME
        1)BUILD TIME (compile)
          prepare app code for compilation, bundling, optimization -> npm run dev
        2)RUN TIME
          compiled app is actively executing and running, utilizing system resources 
      1)environment
        where application is executed, providing services, components. 
      
        1)client
          Browser in users machine that:
            1)sends requests to server
            2)executes response from server to display the UI.
        2)server
          Computer in data center that:
            1)stores application code
            2)receives request from a client
            3)sends response to client
        WHY
          Several operations are more suited to one environment than another.

      2)request-response lifecycle
        Initiated when user interacts with application

        1)user action
          any interaction that requires communication with the server
        2)http request
          client sends http request with necessary informaton about resource request
        3)server
          processes request and sends appropriate response
        4)http response
          after processing, sends appropriate response
        5)client
          parses resource and renders UI
        6)user action
          afer ui rendered,user starts an action again, looping the process.

      3)network boundary
        Conceptual line separating client and server

        Behind the scenes, the work is split into
          1)client module graph
              all the components rendered on the client
          2)server module graph
              all components rendered on the server
        HOW
          "use client"
          "use server"

    1)CLIENT VS SERVER COMPONENTS
      0)REACT VS NEXT DIFFERENCE
        REACT
          Everything in the client
        NEXT
          Allows to combine client & server rendering

          Next js 12<
            SSR rendering limited only to pages

          Next js 13>
            SSR rendering component level opening client vs server component paradirm

      1)CLIENT COMPONENT
        Pre-rendered on server creating static shell, finishing rendering on client with hydration on the things requiring
          1)interactivity
          2)browser  

        HOW  
          Interactivity elements are left as placeholders during PRE SERVER SIDE RENDERING. 

        SYNTAX
          "use client" at the top of the component file.

        WHEN TO USE
          1)interactivity
            1)click button
            2)input and forms
            3)triggering events
          2)react hooks
          3)browser only apis
          4)custom hooks
          5)react class components

        ANALOGY 
          Entire LEGO set dumped on desk at once to build
        PROBLEM
          performance affected, b/c this process it too reliant on users internet and device.

      2)SERVER COMPONENT
        WHAT
          Rendered on the server.
        HOW
          Executed and resolved into HTML on the server and sent to the client to display.

          WHEN IS IT EXECUTED
            Static Side Rendering
              Build time
            Dynamic Side Rendering
              Request time

        WHEN TO USE
          1)access server side resources directly or db
          2)fetch data
          3)static content
          4)server side computation
          5)large dependencies
          6)sensitive api information

        Effect
          1)faster and improved performance

        SYNTAX
          By default, components in next.js are server components, unless otherwise specified.

        ANALOGY
          STATIC
            entire LEGO set build on server and brought already built to the client
          DYNAMIC
            static shell built entirely ONLY dynamic pieces left to build in the client

    2)CLIENT SIDE RENDERING
      Same as the definition of the client component
    
    3)SERVER SIDE RENDERING
      Write UI that can be RENDERED and CACHED on the server

      HOW TO USE
        By default, all components are server components unless otherwise specified, and server components use server side rendering

      WHY RENDER ON SERVER
        1)improve performance on request
          Reducing time to complete b/c of closeness of data source
        2)js bundle is reduced, html is ready improving:
          1)Reduce Initial Load Time(ILT)
          2)Reduced FCP(FIrst Contentful Paint
          3)Better SEO
        3)Logic Simplified
          No need for client hooks
        4)Automatic Request Deduplication
          Reduce unnecessary API calls by analyzing identical requests and eliminating all but 1.
        5)Improved Security
          Protect tokens and API keys
        6)Reduced Network Waterfall
          Requests are more parallelized instead of waterfalled in the server.
        
      SERVER RENDERING STRATEGIES(different ways to display)
        1)Static Site Generation(default) 
          HTML pages generated at build time when deploying site NOT when user requests it.

          WHEN(runtime/build time)
            1)Static(as the name suggests) pages
            2)unchanging not dynamic data on page

          EXAMPLE
            1)static blog post
            2)product page

          UPDATE
            Required rebuilding ENTIRE site
          
        2)Dynamic Rendering
          HTML pages genearted for each user at request time

          WHEN RUNS(runtime/build time)
            request time
          
          WHEN USE
            1)Data personalized to the user
            2)Contains information from a dynamic API
            3)authentication
            4)real time chat platforms
            5)video streaming services
        
          DYNAMIC API
            Information only known at request time and not ahead of time during pre rendering

            TYPES
              1)cookies
              2)headers
              3)connection
              4)draftmode
              5)searchparams
              6)unstable_nostore

        3)Streaming
          Progressive rendering UI from server

          SCIENCE
            Work is split into chunks and streamed into client as it becomes ready.

          WHY
            Allows user to see part of page immediately BEFORE entire content is ready

          HOW
            loading + React Suspense(other section)

        4)ISG(Incremental Static Regeneration)
          Allows update of static content from SSG after site build WITHOUT rebuilding ENTIRE page

          BUILD TIME
            most static

          RUNTIME
            dynamic content when needed

          METHODS TO USE
            1)time based revalidation
              Revalidates entire page after a set ammount of time

              HOW
                export revalidate const with value in ms on top of the page file
                
              WHAT HAPPENS
                Route segment config affecting entire page with all fetches inside

              EXAMPLE
                export const = revalidate = 3600

            2)revalidate request after a set ammount of time
              HOW
                options parameter in fetch function with revalidate prop and value in ms

              WHAT HAPPENS
                Affects only speciic fetch

              EXAMPLE
                const data = fetch("url", {next:{revalidate:3600}})

            3)On Demand Validation
              Instead of depending on time, use revalidatePath for ondemand revalidation of content

        5)Partial Pre Rendering(PPR)
          Combines static and dynamic rendering

          WHY
            Allows to render static shell of page WHILE streaming dynamic content

          HOW
            1)on build time, generates static shell of page (every static part)
            2)placeholders are rendered instead of dynamic content with the use of suspense wrappers
            3)on request time, static shell served immediately
            4)dynamic content streamed in as becomes available

          TYPE OF COMPONENTS 
            1)static
            2)dynamic
            3)partially static & dynamic

    1)COMPOSITION PATTERNS
    2)PARTIAL PRERENDERING
    3)RUNTIMES

	3)SEO & METADATA [dt:08/04/25]
    Using metadata to improve SEO

    Metadata
      Description data that provides information about the project or webapp. Not part of the actual content the user interacts with. 
      
      Helps (...) understand the content better
        Browser
          enhances user experience
        search engines
          like an explanation of the project
        social platforms 
          open graph rich previews

      DEFAULT METADATA
        Even if none of the ways is used, these always get auto generated and can be overwritten:
          1)meta charset tag
            <meta charset="utf-8" />
          2)meta viewport tag
            <meta name="viewport" content="width=device-width, initial-scale=1" />

      Ordering
        Metadata is evaluated in order, starting from the root segment down to the segment closest to the final page.js segment. For example:
          1)app/layout.tsx (Root Layout)
          2)app/blog/layout.tsx (Nested Blog Layout)
          3)app/blog/[slug]/page.tsx (Blog Page) -> evaluated last gets priority

      With all the options below:
        Next.js will automatically generate the relevant <head> tags for your page, which can be inspected in the browser's developer tools.

        1)The static metadata object
          Create and export metadata object in:
            1)layout.ts 
              EXAMPLE
                export const metadata: Metadata = {
                  title: "Hello Nextjs",
                  description: "Generated by create next app",
                }
            2)page.ts
              EXAMPLE
                export const metadata: Metadata = {
                  title: "About",
                  description: "Its the about page",
                }
          HOW
            Next auto detects it and turns it into meta tags
    
        2)The dynamic generateMetadata function
          You can use the function to fetch metadta that depends on data. For example, fetching a specific title and description for a specific blog post.

          EXAMPLE
            export async function generateMetadata({params}){
              const {id} = params 
              const resource = await getResourceById({id})

              const title = resource.title  + " | JS Mastery"
              const seoDescription = "Free resources database containing ebooks"

              return {
                title,
                description: seoDescription
                other: {...}
              }
            }
      
          REQUISITE
            only server components

          RETURNS
            Dynamic object that gets analyzed the same way the static Metadata object does.

            Memoizing data requests
              To avoid duplicate requests, you can use React's cache function to memoize the return value and only fetch the data once. 

              EXAMPLE
                import { cache } from 'react'
                import { db } from '@/app/lib/db'
                
                // getPost will be used twice, but execute only once
                export const getPost = cache(async (slug: string) => {
                  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })
                  return res
                })

          HOW DYNAMIC
            1)access to params from dynamic segments
            2)Next auto detects and converts to metatags

          WHERE
            1)layout
            2)page

          WHEN
            Dynamic data relevant to the user

        3)File based metadata
          WHERE
            directly inside app folder 

          HOW
            Next auto detects files and generates meta tags 

          DETAILS
            Just about adding the files with the right names.

          ABSTRACTION
            No need to config the tags, just add the files. Next does the config for you.

          TYPES OF FILES
            1)open-graph
              Created through the ImageResponse constructor that allows for generating dynamic images with jsx and css. 
            2)favicon
              Small icons that represent site in bookmarks and search results.

              WHERE
                root
            3)robots
            4)sitemaps
            5)icons

          EXAMPLES
            app
              favicon.ico
              icon.svg
              opengraph-image.jpg
              twitter-image.png

          ORDER
            Ranked highest among 3 types of metadata. 

  4)IMAGES AND FONTS [dt: 14/04/25]
    Next comes with auto image and font optimization.

    1)The Next.js <Image> component
      extends the HTML <img> element to provide:
        1)size optimization
          auto serves correctly sized images 
        2)visual stability
          prevents layout shift when images are loading
        3)faster page loads
          only load images when they enter the viewport with lazy loading
        4)asset flexibility
          resize images on demand

      usage example
        import Image from 'next/image'
 
        export default function Page() {
          return <Image src="" alt="" />
        }
      
      src property can be:
        1)local
        2)remote

      1)local images
        static images stored in the public folder 

        example
          import profilePic from './me.png'
          src={profilePic}

        src
          /images/image

          Next sends a request to /images/photo.jpg, does not matter if component is 10 levels deep in the file tree.

        
        props
          width, height, blurDataURL
            1)based on the imported photo determines width and height
            2)determines the image ratio and prevents CLS(cummulative layout shift)
          
      2)remote images
        provide a URL string for the source property 

        example
          src="https://s3.amazonaws.com/my-bucket/profile.png"

        props
          need to provide width, height, blurDataURL, next does not have access to remote files
        
        Requirement
          provide permission to next in the next.config.js to safely allow images from a server, a url list is needed.

          example
            const config: NextConfig = {
              images: {
                remotePatterns: [
                  {
                    protocol: 'https',
                    hostname: 's3.amazonaws.com',
                    port: '',
                    pathname: '/my-bucket/**',
                    search: '',
                  },
                ],
              },
            }
        
    2)OPTIMIZING FONTS
      MODULE
        next/font

      BENEFIT
        1)auto optimizes font
        2)removes external network request improving privacy
        3)built in self hosting for any font file

      GOOGLE FONT
        You can auto self host any google font

        HOW TO USE
          1)Import from next/font/google
          2)call as a function with approprite options
          3)set the classname of the element to apply to

        HOW IT WORKS
          1)Fonts are fetched and hosted locally during build time.
          2)They’re not loaded from Google Fonts CDN at runtime.
          3)Next.js downloads the font files and serves them just like local fonts.
          4)Like next/font/local, it handles preloading, subsetting, and optimizing automatically.

        PROS
          1)Same performance/privacy benefits as local fonts.
          2)No need to manually download and convert fonts.

        FONT WEIGHT
          VARIABLE FONT
            no need to specify font weight
          
          NON VARIABLE FONT
            singular
              weight: '400',

            multiple weights
              const roboto = Roboto({
                weight: ['400', '700'],
                style: ['normal', 'italic'],
                subsets: ['latin'],
                display: 'swap',
              })  
              
        NAME SYNTAX
          Use an underscore (_) for font names with multiple words. E.g. Roboto Mono should be imported as Roboto_Mono.

        SPECIFYING A SUBSET
          Google fonts are auto subsetted, you'll need to specify which subset you need.
          
          WHAT IS A SUBSET
            The practice of creating a “subset” of a font—a file that contains a custom (and usually limited) collection of glyphs.

          SYNTAX
            const inter = Inter({ subsets: ['latin'] })

        EXAMPLE
          import { Geist } from 'next/font/google'
 
          const geist = Geist({
            weight: '400'
            subsets: ['latin'],
          })
          
          export default function Layout({ children }: { children: React.ReactNode }) {
            return (
              <html lang="en" className={geist.className}>
                <body>{children}</body>
              </html>
            )
          }

        HOW TO USE 
          1)FUNCTION 
            The first approach is to create a utility function that exports a font, imports it, and applies its className where needed. 

            STEPS
              1)add font file in /fonts folder
              2)import font in layout.ts
                import Applied globally
              3)import font in page.ts
                import Applied where needed

          2)CSS VARIABLE
            CSS VARIABLE HISTORY
              1)Declaring a variable with scope
                :root {                     -> makes it global(variable scope) pt 1
                  --primary-color: #3498db; -> variable name : variable value  pt 2
                  --font-size-base: 16px;
                }
              
              2)Using a variable where needed 
                body {
                  color: var(--primary-color);
                  font-size: var(--font-size-base); -> is using it somewhere pt3
                }
            USING CSS VARIABLES IN NEXTJS
              1)The Css Way
                1)create variable property in the function of the font
                  const inter = localfont({     
                    src: './fonts/InterVF.ttf',
                    variable: "--font-inter", -> this defines the variable like pt2 of normal css variables
                  })

                  SCOPE
                    where this font variable is created, determines where it can be used. 

                    Layout
                      everywhere
                    Page
                      specific

                2)use in the html tag
                  <body                       -> this defines the scope like pt1 of normal css variables
                    className={`${inter.variable} antialiased`} 
                  >
                3)use anywhere in the css (globall.css) file
                  body{
                    font-family: var(--font-inter); -> same usage as in the normal css pt 3
                  }
                

              2)The tailwind way
                1)same
                2)same
                3)add to tailwind config to use and have intellisense pop it up 
                  fontFamily: {
                    inter: ["var(--font-inter)"],
                  }
                4)use anywhere via tailwind classes:
                  <h1 className="text-3xl text-red-400 font-inter">Home Page</h1>
        
      LOCAL FONT
        HOW TO USE 
          1)import from next/font/local
          2)specify source of font file

        INSIDE OF THE WORKING
          1)The font file is imported at build time.
          2)Next.js moves it to the .next/static/media folder.
          3)It's served locally via your domain (e.g., /_next/static/media/my-font.woff2), reducing reliance on third parties like Google Fonts.
          4)It's optimized and preloaded automatically via the <link rel="preload"> tag.

        PRO
          1)Faster performance (no third-party request).
          2)Privacy-friendly (no tracking from Google Fonts).
          3)Automatic font subsetting and optimization.
        
        EXAMPLE
          import localFont from 'next/font/local'
 
          const myFont = localFont({
            src: './my-font.woff2',
          })
          
          export default function RootLayout({
            children,
          }: {
            children: React.ReactNode
          }) {
            return (
              <html lang="en" className={myFont.className}>
                <body>{children}</body>
              </html>
            )
          }
        
        MULTIPLE FILES FOR SINGLE FONT FAMILY
          src will be an array
            src: [
              {
                path:
                weight:
                style
              }
            ]
        
5)PROJECT SETUP [dt: 11:04/25]
	1)CREATE NEXTJS APP
    INSTALL
		  npx create-next-app@latest
    TURBOPACK
      next gen bunlder wrriten in rust
      BENEFITS
        Faster start up times
        quicker updates
        improved memory efficiency
    DEV DEPS / NON DEV DEPS
      Non dev deps are shipped to prod
  FILES
    next-env.d.ts (TypeScript Environment Declaration File)
      Tells ts about the types that next.js offers automatically. 
      Helper that ts uses bts to work nicely with next.js

    next.config.ts (Next.js Configuration File)
      Config how next behave. Similar to tailwind.config.ts / tsconfig.json.

    eslint.config.mjs — Modern ESLint Config (Flat Config)
      Configs eslint, telling it how to configure code. 

    postcss.config.mjs — PostCSS Configuration (Modern Module Format)
      Configs postcss, telling it how to process your CSS(tailwind, autoprefixer, nesting)
      
      POSTCSS
        platform for transforming css with js plugins.

    NEXT folder
      Compiled version of app.

      INSIDE
        cache/	
          Caches builds to speed things up
        server/	
          Contains server-side rendered pages
        static/	
          Includes optimized static files (images, JS chunks, etc.)
          build-manifest.json	Maps routes to JS/CSS bundles
        routes-manifest.json	
          Info about dynamic/static routes
        middleware-manifest.json	
          Info about edge functions/middleware
        app/ or pages/	
          Transpiled and bundled page components
        trace files	
          For analyzing performance and tracing server code
          
      CAN BE DELETED
        Yes, next creates another on build

    HOT MODULE REPLACEMENT
      Update in real time based on changes to the code, without affecting states (forms, inputs, scroll positions.)

      HOW
        1)detects changes
        2)rebuilds only changed modules
        3)sends updated module to browser
        4)replaces old module on fly
    
    EXPORTING COMPONENTS
      NAMED FUNCTIONS
        can do inline default export 
      ARROW FUNCTIONS
        can not do inline default export 
	2)GIT & GITHUB SETUP
      GIT
        version control tracking changes & collab
      GITHUB
        online platform for storing and sharing
      STRATEGY
        constanly commit and push for each individual lesson to check state of codebase 
    
	3)ESILNT & PRETTIER SETUP [dt:12/04/25]
    0)FILE CONVENTION
      PREVIOUS(Eslint v8-)
        .json
      NEWER (eslint v9+)
        .js / .mjs

        .MJS
          Module javascript, indicates the file uses ES Modules(ESM) and is compatible with features like "import" / "export"

    1)PLUGINS
      npm module that adds new rules for specific libraries.

      HOW(GENERIC)
        1)install plugin 
          e.g: npm install eslint-plugin-react --save-dev
        2)enable rules manually or through a config
          e.g: {
                "plugins": ["react"],
                "rules": {
                  "react/jsx-uses-react": "warn"
                }
              }

      1)TAILWIND
        eslint-plugin-tailwindcss
          Rules enforcing best practices and consistency using Tailwind CSS.
        
        SUPPORTED RULES
          1)classnames-order
          2)enforces negative arbitrary values
          3)enforces shorthand
          4)no arbitrary values
          5)no custom classnames
          6)no contradicting classnames
          7)no unnecessary arbitrary value

        WITH ESLINT EXTENSION
          all the rules will provide error messages in UI

        SET UP
          1)install
            $ npm i -D eslint eslint-plugin-tailwindcss
        
          2)config file(.js, .mjs)
            const eslintConfig = [
            ...compat.extends(
              "plugin:tailwindcss/recommended", -> imports as plugin + uses recommended settings(as config)
            ),
              
        OPTION WITH PRETTIER
          prettier-plugin-tailwindcss
            not necessary right now, it is only for prettier to format tailwindcss accordingly, but with the eslint-plugin-tailwindcss, eslint does it. 

      2)IMPORT
        eslint-plugin-import
          helps validate and manage import/export syntax in your JavaScript or TypeScript code.

        SET UP
          1)install
            npm i -D eslint-plugin-import 

          2)add as config in config file
            const eslintConfig = [
            ...compat.plugins("import"),
            ),
          3)add rules(needed when using configs)
            rules: {
              "import/order": [
                ...
              ],
            },
        
    2)CONFIGS
      Predefined set of rules or options from a plugin(more like conventions applied by others to be used, not like something extra for a module)

      1)eslint-config-standard
        js style guide, linter, formatter

        INCOMPATIBILITY
          No longer compatible with eslint v9+.
          Not worth to downgrade b/c create next app brings eslint v9+.
        
      2)eslint-config-prettier
        This ESLint config disables formatting rules from eslint that conflict with Prettier and lets prettier handle all formatting.
        Esling focuses on linting errors.
  
        ASSUMPTION
          It assumes you have Prettier installed in the project.

        REQUIREMENT
          install prettier if not installed
            npm i -D prettier

        The VS Code extension:
          It only runs in your local editor.

        SET UP
          1)install
            npm i -D eslint-config-prettier

          2)config file: add in the extends section
            const eslintConfig = [
            ...compat.plugins("import"),
            ...compat.extends(
              "prettier"
            )
        
    3)LEGACY DEPS
      flag to install deps that are deprectaed
        --legacy-peer-deps(not needed if downgraded tailwind v4-v3)

    4)Settings.json 
        "editor.codeActionsOnSave": {
          "source.fixAll.eslint": "explicit",     -> fixes errors found by eslint whenever you save the file(will also fix the tailwind classes b/c of this)
          "source.addMissingImports": "explicit"  -> adds missing imports from the eslint-plugin-import when saving the file
        }
      Format on save (prettier)
        "editor.formatOnSave": true               -> commands formats with prettier when saving files 

	4)TAILWIND CSS SETUP [dt:13/04/25]
    1)DOWNGRADING TO V3
      1)Uninstall Tailwind v4
        npm uninstall tailwindcss @tailwindcss/postcss @tailwindcss/node

      2.1)Install Tailwind CSS v3
        npm install -D tailwindcss@^3 postcss autoprefixer

      2.2)Then reinit Tailwind(this creates tailwind config file)
        npx tailwindcss init -p 

      3)Adjust Tailwind Config File(tells tailwind where to scan for tailwind classes)
        module.exports = {
          content: [
            "./app/**/*.{js,ts,jsx,tsx,mdx}",          
            "./pages/**/*.{js,ts,jsx,tsx,mdx}",
            "./components/**/*.{js,ts,jsx,tsx,mdx}",
        
            // Or if using `src` directory:
            "./src/**/*.{js,ts,jsx,tsx,mdx}",
          ],
          theme: {
            extend: {},
          },
          plugins: [],
        };
      4)Add tailwind directives at top of CSS file(tells tailwind what to import to your project)
        @tailwind base;
        @tailwind components; 
        @tailwind utilities;

    2)PostCSS & Autoprefixer
      PostCSS
        Transforms CSS with plugins
                    
        config
          "Hey, when you're building CSS, first run Tailwind, then Autoprefixer."

          module.exports = {
            plugins: {
              tailwindcss: {}, 
              autoprefixer: {},
            },
          };

        NOT USED
          tailwind can't be used

        
      Autoprefixer
        Autoprefixer adds vendor prefixes to your CSS automatically, so you don’t have to write things like:

        -webkit-transform: ...;
        -ms-transform: ...;
        transform: ...;

        And ensures browser compatibility

        NOT USED
          css might break in older browser

    3)Tailwind.config.js setup
      WHY
        If not, detailed config will require too much repetition and poor effectivity.

      SOLUTION
        Modify configurations in the tailwind.config.ts file to reuse

      extend color
        Adds new colors and allows them to be used besides the ones that already exist

        e.g: 
          theme:{
            extend:{
              colors: {
                light: {
                  900: "#FFFFFF"
                }
              }
            }
          }
      CUSTOMARY ITEMS TO CUSTOMIZE
        1)color
        2)spacing
        3)borderRadius
        4)boxshadow
        5)screen sizes
      
  5)TAILWIND CSS THEMING [dt:13/04/25]
    1)Layers
      Tailwind uses the layers to apply styles in a specific order.

        1)base
          Use this to define or override base-level styles, like HTML tags.

          example
            @layer base {
              h1 {
                @apply text-3xl font-bold;
              }

              body {
                @apply bg-light-900 text-dark-200;
              }
            }
          when
            typography
            default spacing
            global reset
        2)components
          Use this to define reusable classes with multiple utility classes.

          example
            @layer components {
              .btn {
                @apply px-4 py-2 bg-primary-500 text-white rounded;
              }

              .card {
                @apply shadow-md p-6 rounded-lg bg-white;
              }
            }
          when
            custom ui blocks
        3)utilities
          Use this when you want to add new utilities or override existing ones.
          
          example
            @layer utilities {
            .content-auto {
              content-visibility: auto;
            }

            .text-shadow {
              text-shadow: 2px 2px #000000;
            }
          }
          
          when
            Ideal for one-liner utility styles you want available as classes like text-shadow.
    2)Pugins
      1)@tailwindcss/typography
        Provides set of pre styled classes for rich text content like blog posts, articles, markdown.

      2)tailwindcss-animate
        Ready to use animation utility classes powered by motion.dev
        Saves the work of defining keyframes manually

      3)SETUP
        1)install
          npm install -D @tailwindcss/typography
          npm install -D tailwindcss-animate
        2)import in tailwind config
          import typography from "@tailwindcss/typography";
          import animate from "tailwindcss-animate";
        3)add as plugins
          plugins: [animate, typography]

  6)SETUP LOCAL FONT
    Process used for inter & space-grotesk
      1)move file to /font folder
        interVF.ttf

      2)import localfont from nextjs
        import localfont from "next/font/local"

      3)create inter localfont object with a custom var as prop
        const inter = localfont({
          src: './fonts/InterVF.ttf',
          variable: "--font-inter",
          weight: "100 200 300 400 500 600 700 800 900"
        })

      4)define global scope availability for variable(css root declaration for variable)
        <body
          className={`${inter.variable} antialiased`}
        >
          {children}
        </body>

      5)use variable in the global.css file
        This will apply it to wherever you choose
        body{
          font-family: var(--font-inter);
        }

      6)add to the tailwind config file
        This will allow intellisense to pick it up, suggest it and for you to use wherever needed

        fontFamily: {
          inter: ["var(--font-inter)"],
        }
    Difference of how to use inter & space-grotesk
      Inter
        HOW
          inter.className
        WHY
          applies classname for the entire body, meaning it will be applied everywhere. No extra config needed.

        WHAT HAPPENS
          .inter-font {
            font-family: 'Inter Variable', sans-serif;
          }
          <body className="inter-font"

      Space Grotesk 
        HOW
          inter.variable
        WHY
          allows the variable to be available everywhere for use
        WHAT HAPPENS
          :root {                     -> makes it global(variable scope) pt 1
            --font-space-grotesk;     -> variable name : variable value  pt 2
          }
        HOW TO USE
          either in css with a selector or tailwind via the tailwind class

	7)ASSETS AND METADATA
    All static assets from the figma need to be imported to the project repository
      1)images
      2)logos
      3)icons

    How to hide files and folder from appearing in vs code
      settings.json
        "files.exclude": {
          "**/.vscode": true,
          "**/.next": true,
          "**/node_modules": true,
          "next-env.d.ts": true
        }
6)NEXTJS ROUTING[19/04/25]
	FILE BASED
    repeat vid...
	ADVANCED
    repeat vid...
7)ARCHITECTURE[19/04/25]
	BIRTH OF SERVER COMPONENT
    repeat vid...
	CLIENT VS SERVER PARADIGM
    repeat vid...
	DIFFERENT RENDERING STRATEGIES
    repeat vid...
8)LIGHT AND DARK THEME [21:04:25]

	NEXT-THEMES PACKAGE
    Library makes it easy to manage light/dark system themes in a nextjs app. 

    WHY
      1)dark/light toggle
      2)respect the system preference
      
  HOW TO USE
    INSTALL
      npm i next-themes    

    CREATE THEME PROVIDER
      "use client"

      import { ThemeProviderProps } from 'next-themes'
      import { ThemeProvider as NextThemeProvider } from 'next-themes'
      import React from 'react'

      const ThemeProvider = ({children, ...props}: ThemeProviderProps) => {
        return (
          <NextThemeProvider {...props}>{children}</NextThemeProvider>
        )
      }

      export default ThemeProvider

    WRAP APP AROUND PROVIDER
      import ThemeProvider from "../../context/Theme";

      <ThemeProvider
        attribute="class"
        defaultTheme="system"
        enableSystem
        disableTransitionOnChange
      >
        {children}
      </ThemeProvider>

      WHAT DOES
        theme: current theme (e.g. "light", "dark", or "system")
        setTheme(theme): a function to switch themes
        resolvedTheme: what theme is actually being used (light/dark), even if theme is set to system
        and other helpers like themes and systemTheme

  REQUIRENT FOR THIS TO WORK
    darkMode: 'class', // 
      Tells tailwind: “Only apply dark mode styles when there’s a class="dark" on a parent element — usually the <html> tag.”

  PROPS
    1)attribute="class"
      The ThemeProvider injects a class or data attribute into the DOM for you, depending on how you configured it:
        1)If attribute="class" → adds class="dark" or class="light" to the <html> tag.
        2)If attribute="data-theme" → adds data-theme="dark" or data-theme="light".
      
      ABSTRACTION
        This happens automatically whenever the theme is toggled.
        You don’t need to touch document.documentElement.classList.add() or anything like that.

      WHY
        tailwind expects a dark class to be toggled on the html.
        EXAMPLE
          darkMode: "class" / <html class="dark">
  
    2)defaultTheme="system"
      set initial theme to match user preference 
    3)enableSystem
      enable auto theme switching when user system theme changes allowing to:1)switch in ls, 2)auto respond to system theme changes

      ABSTRACTION
        next-themes uses the window.matchMedia('(prefers-color-scheme: dark') API behind the scenes to detect whether the user's OS is in dark or light mode.

        It will:
          Apply the correct theme initially
          Listen for changes to system preferences and update the theme reactively

    4)disableTransitionOnChange
      prevents weird flickers when switching between themes, temporarilly disables all css transitions when switching themes.
    
  CHANDN PACKAGE
    Collection of beautifully designed UI components built with tailwind CSS
    
    DIFFERENCE WITH MUI / CHAKRA
      not a copy paste, you own code and customize it

    WHY
      customizable
        no more fightning the library style
      tailwind first
        build with tailwind in mind
      headless logic
        raix ui under the hood
      prebuilt components
        modals, tooltips,toasts,dropdowns,themes
      built in support for dark/light theme
        already setup with tailwinds darkmode: class setup
    
    RUN
      npx shadcn-ui@latest/version(2.3.0 for tailwind v3) init -> will force the install

      WHAT HAPPENS
        1)components.json created
          Includes shadcn configurations
        2)updates tailwind.config.mjs
          darkMode: ["class"]
        4)updates src/aapp/globals.css
        5)installs deps
        6)created lib/utils.ts file
          Helper to manage class conditions without using helper strings
        

    ADD DROPDOWN
      install
        npx shadcn@latest add dropdown-menu

      WHAT HAPPENS
        Every component is added to the components/ui folder
      
      import and use
        import {
          DropdownMenu,
          DropdownMenuContent,
          DropdownMenuItem,
          DropdownMenuLabel,
          DropdownMenuSeparator,
          DropdownMenuTrigger,
        } from "@/components/ui/dropdown-menu";

        <DropdownMenu>
          <DropdownMenuTrigger>Open</DropdownMenuTrigger>
          <DropdownMenuContent>
            <DropdownMenuLabel>My Account</DropdownMenuLabel>
            <DropdownMenuSeparator />
            <DropdownMenuItem>Profile</DropdownMenuItem>
            <DropdownMenuItem>Billing</DropdownMenuItem>
            <DropdownMenuItem>Team</DropdownMenuItem>
            <DropdownMenuItem>Subscription</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>

	CREATING A NAVBAR
    navigation/navbar
      index.tsx -> entire navbar
        
	CREATE A THEME TOGGLER
    navigation/navbar
      Theme.tsx
        1)copy code drom shadcn toggler
        2)install necessary components(button)
        3)import on navbar component

    LOGIC
      1)import from next themese
        import { useTheme } from "next-themes"; -> next-themes function that controls the theme
      2)use from next themes
        const { setTheme } = useTheme();
      3)action with the shadcn component on the logic from next-themes
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>

8)AUTHENTICATION
	WHAT
	HTTP STATE MANAGEMENT MECHANISMS
	CREATE AUTH ROUTES
	CREATE AUTH LAYOUT & SOCIAL AUTH FORM
	SETUP NEXTAUTH WITH GITHUB PROVIDER
	IMPLEMENT GITHUB SIGNIN
	IMPLEMENT GOOGLE SIGNIN
	CREATING AUTH FORM
9)APPLICATION NAVIGATION
	MOBILE NAVIGATION
	ACTIVE LESSON: LEFTSIDEBAR
	IMPLEMENT LEFTSIDEBAR
	IMPLEMENT RIGHT SIDEBAR
10)STATE MANAGEMENT
11)HOME PAGE
12)ASK A QUESTIONS PAGE
13)DEVELOP YOUT BACKEND
14)ERROR & LOG HANDLERS
15)API ROUTES(ROUTE HANDLER)
16)AUTHENTICATION II: SOCIAL AUTH ACCOUNTS
17)SERVER ACTIONS
18)AUTHENTICATION III: EMAIL PASSWORD AUTH
19)QUESTION SUBMISSION
20)HOME PAGE
21)TAGS PAGE 
22)QUESTION DETAILS
23)ANSWER SUBMISSION 
24)AI INTEGRATION 
25)VOTING SYSTEM
26)COLLECTIONS PAGE
27)COMMUNITY PAGE
28)FILTERS AND PAGINATION 
29)SHOW TOP RESULTS 
30)PROFILE PAGE
31)ADVANCED NEXTJS
-->
